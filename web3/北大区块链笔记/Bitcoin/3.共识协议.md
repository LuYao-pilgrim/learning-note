# 共识协议

双花攻击，中心化

## 防范双花攻击

哈希指针有两种

1.指向prev block证明在区块链上

2.指向prev币的来源

**问题**：怎么去确认转钱的公钥是否存在（没有中心化数据库去记录每一个公钥）？转进一个没人的账户成了死钱？

## 公钥即身份

给B转钱-->给B公钥的哈希转钱

在Bitcoin中，没有实际的物理地址IP地址，每个人以公钥私钥形式参与网络，转给公钥的哈希-->在之后他的交易中可以明确指明币的来源即可

我在整个系统网络中，就是拿着我的公钥去干任何事情，任何人拿到我的公钥就可以验证我的信息，给我转钱，我给别人转钱验证coin来源，公钥即我的身份

## 区块链具体包含

block header --- block body

**header:**

version:比特币版本

hash of previous block header:连接区块链，防止篡改，只算上一个的header, 因为merkle tree可以保证整个不变，只算块头可以节约计算时间，所以其实具体是一个个header连在一起

merkle root hash:当前块包含交易防篡改

target, nonce:证明这是一次成功的挖矿

**body:**

tx list:包含具体的交易

## 分布式共识

全球唯一账本如何维护一致？

分布式：CAP三选二，一致性，高可用性，分区容忍性

一般在C,A中取舍

最长链原则-->两个人同时合法挖出一个区块，开始竞争，看哪一个区块先挖出下一个区块（传播的速度大于挖出区块的速度），大家到长的那个链去，另一个孤儿块被抛弃。如果要抗争，需要掌握超过全球50%的计算力。大部分人还是希望比特币好好运行的，所以会有这个共识。恶意节点因为输入公钥对不上，大部分人也不会去认可。

所以是要six confirm去基本确保已经在区块链上，才能确保交易

**问题：** 比如我吃饭支付比特币，难道要等1个小时才能吃到饭？这种及时性的交易怎么办

**问题：** 出块奖励是立即生效？那万一变成孤儿块怎么收回

解答：大家共识是依据最长链的交易记录来的，所以你下面那个孤儿块的比特币成为死钱，不在交易流中，没有作用。

**问题：** 如果真的有一个哈希碰撞出现了怎么办？
